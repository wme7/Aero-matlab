<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<title>kspaceFirstOrder3D :: Functions (k-Wave)</title>
	<link rel="stylesheet" href="docstyle.css" type="text/css">
</head>

<body>

<table width="100%" border="0" cellpadding="0" cellspacing="0" bgcolor="#e7ebf7">
    <tr>
        <td valign="baseline">
            <b>k-Wave Toolbox</b>
        </td>
        <td valign="baseline" align="right">
            <a href="kspaceFirstOrder2D.html"><img src="images/b_prev.gif" border="0" align="bottom" alt="Previous"></a>&nbsp;&nbsp;&nbsp;<a href="kspaceFirstOrder3DC.html"><img src="images/b_next.gif" border="0" align="bottom" alt="Next"></a>
        </td>
    </tr>
</table>

<a name="top_of_page"></a>
<h1 class="reftitle">kspaceFirstOrder3D</h1>
<p class="purpose">3D time-domain simulation of wave propagation</p>

<h2>Syntax</h2>

<pre class="programlisting">
sensor_data = kspaceFirstOrder3D(kgrid, medium, source, sensor)
sensor_data = kspaceFirstOrder3D(kgrid, medium, source, sensor, ...) 
</pre>

<h2>Description</h2>
<p><code>kspaceFirstOrder3D</code> simulates the time-domain propagation of compressional waves through a three-dimensional homogeneous or heterogeneous acoustic medium given four input structures: <code>kgrid</code>, <code>medium</code>, <code>source</code>, and <code>sensor</code>. The computation is based on a first-order k-space model which accounts for power law absorption and a heterogeneous sound speed and density. If <code>medium.BonA</code> is specified, cumulative nonlinear effects are also modelled. At each time-step (defined by <code>kgrid.t_array</code>), the acoustic field parameters at the positions defined by <code>sensor.mask</code> are recorded and stored. If <code>kgrid.t_array</code> is set to <code>'auto'</code>, this array is automatically generated using <code><a href="makeTime.html">makeTime</a></code>. An anisotropic absorbing boundary layer called a perfectly matched layer (PML) is implemented to prevent waves that leave one side of the domain being reintroduced from the opposite side (a consequence of using the FFT to compute the spatial derivatives in the wave equation). This allows infinite domain simulations to be computed using small computational grids.</p>

<p>For a homogeneous medium the formulation is exact and the time-steps are only limited by the effectiveness of the perfectly matched layer. For a heterogeneous medium, the solution represents a leap-frog pseudospectral method with a k-space correction that improves the accuracy of computing the temporal derivatives. This allows larger time-steps to be taken for the same level of accuracy compared to conventional pseudospectral time-domain methods. The computational grids are staggered both spatially and temporally.</p>

<p>An initial pressure distribution can be specified by assigning a matrix (the same size as the computational grid) of arbitrary numeric values to <code>source.p0</code>. A time varying pressure source can similarly be specified by assigning a binary matrix (i.e., a matrix of 1's and 0's with the same dimensions as the computational grid) to <code>source.p_mask</code> where the 1's represent the grid points that form part of the source. The time varying input signals are then assigned to <code>source.p</code>. This can be a single time series (in which case it is applied to all source elements), or a matrix of time series following the source elements using MATLAB's standard column-wise linear matrix index ordering. A time varying velocity source can be specified in an analogous fashion, where the source location is specified by <code>source.u_mask</code>, and the time varying input velocity is assigned to <code>source.ux</code>, <code>source.uy</code>, and <code>source.uz</code>.</p>

<p>The field values are returned as arrays of time series at the sensor locations defined by <code>sensor.mask</code>. This can be defined in three different ways. (1) As a binary matrix (i.e., a matrix of 1's and 0's with the same dimensions as the computational grid) representing the grid points within the computational grid that will collect the data. (2) As the grid coordinates of two opposing corners of a cuboid in the form [x1; y1; z1; x2; y2; z2]. This is equivalent to using a binary sensor mask covering the same region, however, the output is indexed differently as discussed below. (3) As a series of Cartesian coordinates within the grid which specify the location of the pressure values stored at each time step. If the Cartesian coordinates don't exactly match the coordinates of a grid point, the output values are calculated via interpolation. The Cartesian points must be given as a 3 by N matrix corresponding to the x, y, and z positions, respectively, where the Cartesian origin is assumed to be in the center of the grid. If no output is required, the <code>sensor</code> input can be replaced with an empty array <code>[]</code>. Both the <code>source</code> and <code>sensor</code> inputs can also be replaced by an object of the <code>kWaveTransducer</code> class created using <code><a href="makeTransducer.html">makeTransducer</a></code>.</p>

<p>If <code>sensor.mask</code> is given as a set of Cartesian coordinates, the computed <code>sensor_data</code> is returned in the same order. If <code>sensor.mask</code> is given as a binary matrix, <code>sensor_data</code> is returned using MATLAB's standard column-wise linear matrix index ordering. In both cases, the recorded data is indexed as <code>sensor_data(sensor_point_index, time_index)</code>. For a binary sensor mask, the field values at a particular time can be restored to the sensor positions within the computation grid using <code><a href="unmaskSensorData.html">unmaskSensorData</a></code>. If <code>sensor.mask</code> is given as a list of cuboid corners, the recorded data is indexed as <code>sensor_data(cuboid_index).p(x_index, y_index, z_index, time_index)</code>, where <code>x_index</code>, <code>y_index</code>, and <code>z_index</code> correspond to the grid index within the cuboid, and <code>cuboid_index</code> corresponds to the number of the cuboid if more than one is specified.</p>

<p>By default, the recorded acoustic pressure field is passed directly to the output <code>sensor_data</code>. However, other acoustic parameters can also be recorded by setting <code>sensor.record</code> to a cell array of the form <code>{'p', 'u', 'p_max', ...}</code>. For example, both the particle velocity and the acoustic pressure can be returned by setting <code>sensor.record = {'p', 'u'}</code>. If <code>sensor.record</code> is given, the output <code>sensor_data</code> is returned as a structure with the different outputs appended as structure fields. For example, if <code>sensor.record = {'p', 'p_final', 'p_max', 'u'}</code>, the output would contain fields <code>sensor_data.p</code>, <code>sensor_data.p_final</code>, <code>sensor_data.p_max</code>, <code>sensor_data.ux</code>, <code>sensor_data.uy</code>, and <code>sensor_data.uz</code>. Most of the output parameters are recorded at the given sensor positions and are indexed as <code>sensor_data.field(sensor_point_index, time_index)</code> or <code>sensor_data(cuboid_index).field(x_index, y_index, z_index, time_index)</code> if using a sensor mask defined as cuboid corners. The exceptions are the averaged quantities (<code>'p_max'</code>, <code>'p_rms'</code>, <code>'u_max'</code>, <code>'p_rms'</code>, <code>'I_avg'</code>), the 'all' quantities (<code>'p_max_all'</code>, <code>'p_min_all'</code>, <code>'u_max_all'</code>, <code>'u_min_all'</code>), and the final quantities (<code>'p_final'</code>, <code>'u_final'</code>). The averaged quantities are indexed as <code>sensor_data.p_max(sensor_point_index)</code> or <code>sensor_data(cuboid_index).p_max(x_index, y_index, z_index)</code> if using cuboid corners, while the final and 'all' quantities are returned over the entire grid and are always indexed as <code>sensor_data.p_final(nx, ny, nz)</code>, regardless of the type of sensor mask.</p>

<p><code>kspaceFirstOrder3D</code> may also be used for time reversal image reconstruction by assigning the time varying pressure recorded over an arbitrary sensor surface to the input field <code>sensor.time_reversal_boundary_data</code>. This data is then enforced in time reversed order as a time varying Dirichlet boundary condition over the sensor surface given by <code>sensor.mask</code>. The boundary data must be indexed as <code>sensor.time_reversal_boundary_data(sensor_point_index, time_index)</code>. If <code>sensor.mask</code> is given as a set of Cartesian coordinates, the boundary data must be given in the same order. An equivalent binary sensor mask (computed using nearest neighbour interpolation) is then used to place the pressure values into the computational grid at each time step. If <code>sensor.mask</code> is given as a binary matrix of sensor points, the boundary data must be ordered using MATLAB's standard column-wise linear matrix indexing. If no additional inputs are required, the <code>source</code> input can be replaced with an empty array <code>[]</code>.</p>

<p>Acoustic attenuation compensation can also be included during time reversal image reconstruction by assigning the absorption parameters <code>medium.alpha_coeff</code> and <code>medium.alpha_power</code> and reversing the sign of the absorption term by setting <code>medium.alpha_sign = [-1, 1]</code>. This forces the propagating waves to grow according to the absorption parameters instead of decay. The reconstruction should then be regularised by assigning a filter to <code>medium.alpha_filter</code> (this can be created using <code><a href="getAlphaFilter.html">getAlphaFilter</a></code>).</p>

<ul>
    <table cellspacing="0" class="note" summary="Note" cellpadding="5" border="1">
        <tr width="90%">
            <td><p><b>Note</b>&nbsp;&nbsp;To run a simple photoacoustic image reconstruction example using time reversal (that commits the 'inverse crime' of using the same numerical parameters and model for data simulation and image reconstruction), the <code>sensor_data</code> returned from a k-Wave simulation can be passed directly to <code>sensor.time_reversal_boundary_data</code>
            with the input fields <code>source.p0</code> and <code>source.p</code> removed or set to zero.</p></td>
        </tr>
    </table>
</ul>

<h2>Inputs</h2>

<p>The minimum fields that must be assigned to run an initial value problem (for example, a photoacoustic forward simulation) are marked with a *.</p>

<table cellspacing="0" class="body" cellpadding="4" border="0">

    <tr valign="top">
        <td width = "150"><p><code>kgrid*</code></p></td>
        <td><p>k-Wave grid structure returned by <code><a href="makeGrid.html">makeGrid</a></code> containing Cartesian and k-space grid fields</p></td>
    </tr>    
    
    <tr valign="top">
        <td width = "150"><p><code>kgrid.t_array*</code></p></td>
        <td>
            <p>evenly spaced array of time values [s] (set to <code>'auto'</code> by <code><a href="makeGrid.html">makeGrid</a></code>)</p>
        </td>
    </tr>  
    
    <tr valign="top">
        <td><p>&nbsp</p></td>
        <td><p>&nbsp</p></td>
    </tr>       
    
    <tr valign="top">
        <td><p><code>medium.sound_speed*</code></p></td>
        <td><p>sound speed distribution within the acoustic medium [m/s]</p></td>
    </tr>  
    
    <tr valign="top">
        <td><p><code>medium.sound_speed_ref</code></p></td>
        <td><p>reference sound speed used within the k-space operator (phase correction term) [m/s]</p></td>
    </tr>  	
	
    <tr valign="top">
        <td><p><code>medium.density*</code></p></td>
        <td><p>density distribution within the acoustic medium [kg/m^3]</p></td>
    </tr>    

    <tr valign="top">
        <td><p><code>medium.BonA</code></p></td>
        <td><p>parameter of nonlinearity</p></td>
    </tr>  	
	
    <tr valign="top">
        <td><p><code>medium.alpha_power</code></p></td>
        <td><p>power law absorption exponent</p></td>
    </tr> 
    
    <tr valign="top">
        <td><p><code>medium.alpha_coeff</code></p></td>
        <td><p>power law absorption coefficient [dB/(MHz^y cm)]</p></td>
    </tr>     
    
    <tr valign="top">
        <td><p><code>medium.alpha_mode</code></p></td>
        <td><p>optional input to force either the absorption or dispersion terms in the equation of state to be excluded; valid inputs are <code>'no_absorption'</code> or <code>'no_dispersion'</code> </p></td>
    </tr>  

    <tr valign="top">
        <td><p><code>medium.alpha_filter</code></p></td>
        <td><p>frequency domain filter applied to the absorption and dispersion terms in the equation of state</p></td>
    </tr>  

    <tr valign="top">
        <td><p><code>medium.alpha_sign</code></p></td>
        <td><p>two element array used to control the sign of absorption and dispersion terms in the equation of state</p></td>
    </tr>  

    <tr valign="top">
        <td><p>&nbsp</p></td>
        <td><p>&nbsp</p></td>
    </tr>       
    
    <tr valign="top">
        <td><p><code>source.p0*</code></p></td>
        <td><p>initial pressure within the acoustic medium</p></td>
    </tr>     
  
    <tr valign="top">
        <td><p><code>source.p</code></p></td>
        <td><p>time varying pressure at each of the source positions given by <code>source.p_mask</code></p></td>
    </tr>         
    
    <tr valign="top">
        <td><p><code>source.p_mask</code></p></td>
        <td><p>binary matrix specifying the positions of the time varying pressure source distribution</p></td>
    </tr>
	
	<tr valign="top">
        <td><p><code>source.p_mode</code></p></td>
        <td><p>optional input to control whether the input pressure is injected as a mass source or enforced as a dirichlet boundary condition; valid inputs are <code>'additive'</code> (the default) or <code>'dirichlet'</code></p></td>
    </tr>	

    <tr valign="top">
        <td><p><code>source.ux</code></p></td>
        <td><p>time varying particle velocity in the x-direction at each of the source positions given by <code>source.u_mask</code></p></td>
    </tr>     

    <tr valign="top">
        <td><p><code>source.uy</code></p></td>
        <td><p>time varying particle velocity in the y-direction at each of the source positions given by <code>source.u_mask</code></p></td>
    </tr>      
    
    <tr valign="top">
        <td><p><code>source.uz</code></p></td>
        <td><p>time varying particle velocity in the z-direction at each of the source positions given by <code>source.u_mask</code></p></td>
    </tr>  

    <tr valign="top">
        <td><p><code>source.u_mask</code></p></td>
        <td><p>binary matrix specifying the positions of the time varying particle velocity distribution</p></td>
    </tr> 
	
	<tr valign="top">
        <td><p><code>source.u_mode</code></p></td>
        <td><p>optional input to control whether the input velocity is applied as a force source or enforced as a dirichlet boundary condition; valid inputs are <code>'additive'</code> (the default) or <code>'dirichlet'</code></p></td>
    </tr>	

    <tr valign="top">
        <td><p>&nbsp</p></td>
        <td><p>&nbsp</p></td>
    </tr>     
    
    <tr valign="top">
        <td><p><code>sensor.mask*</code></p></td>
        <td><p>binary matrix or a set of Cartesian points where the pressure is recorded at each time-step</p></td>
    </tr>    
    
	<tr valign="top">
        <td><p><code>sensor.record</code></p></td>
        <td><p>cell array of the acoustic parameters to record in the form <code>sensor.record = {'p', 'u', ...}</code>; valid inputs are:<br/>
        <code>&nbsp;&nbsp;'p'</code> (acoustic pressure)<br/>
        <code>&nbsp;&nbsp;'p_max'</code> (maximum pressure)<br/>
        <code>&nbsp;&nbsp;'p_min'</code> (minimum pressure)<br/>
        <code>&nbsp;&nbsp;'p_rms'</code> (RMS pressure)<br/>
        <code>&nbsp;&nbsp;'p_final'</code> (final pressure field at all grid points)<br/>
        <code>&nbsp;&nbsp;'p_max_all'</code> (maximum pressure at all grid points)<br/>
        <code>&nbsp;&nbsp;'p_min_all'</code> (minimum pressure at all grid points)<br/>
        <code>&nbsp;&nbsp;'u'</code> (particle velocity)<br/>
        <code>&nbsp;&nbsp;'u_max'</code> (maximum particle velocity)<br/>
        <code>&nbsp;&nbsp;'u_min'</code> (minimum particle velocity)<br/>
        <code>&nbsp;&nbsp;'u_rms'</code> (RMS particle velocity)<br/>
        <code>&nbsp;&nbsp;'u_final'</code> (final particle velocity field at all grid points)<br/>
        <code>&nbsp;&nbsp;'u_max_all'</code> (maximum particle velocity at all grid points)<br/>
        <code>&nbsp;&nbsp;'u_min_all'</code> (minimum particle velocity at all grid points)<br/>
        <code>&nbsp;&nbsp;'u_non_staggered'</code> (particle velocity on non-staggered grid)<br/>
        <code>&nbsp;&nbsp;'I'</code> (time varying acoustic intensity)<br/>
        <code>&nbsp;&nbsp;'I_avg'</code> (average acoustic intensity)</p></td>
    </tr>
    
    <tr valign="top">
        <td><p><code>sensor.record_start_index</code></p></td>
        <td><p>time index at which the sensor should start recording the data specified by <code>sensor.record</code> (default = 1)</p></td>
    </tr> 
    
    <tr valign="top">
        <td><p><code>sensor.time_reversal_boundary_data</code></p></td>
        <td><p>time varying pressure enforced as a Dirichlet boundary condition over <code>sensor.mask</code></p></td>
    </tr>      
    
    <tr valign="top">
        <td><p><code>sensor.frequency_response</code></p></td>
        <td><p>two element array specifying the center frequency and percentage bandwidth of a frequency domain Gaussian filter applied to the <code>sensor_data</code></p></td>
    </tr>    
    
</table>
    
<ul>
    <table cellspacing="0" class="note" summary="Note" cellpadding="5" border="1">
        <tr width="90%">
            <td><p><b>Note</b>&nbsp;&nbsp;For a heterogeneous medium, <code>medium.sound_speed</code> and <code>medium.density</code> must be given in matrix form with the same dimensions as <code>kgrid</code>. For a homogeneous medium, these can be given as scalar values. If the medium is homogeneous and velocity inputs or outputs are not required, it is not necessary to specify <code>medium.density</code>.</p></td>
        </tr>
    </table>
</ul>

<h2>Optional Inputs</h2>

<p>Optional 'string', value pairs that may be used to modify the default computational settings.</p>

<table cellspacing="0" class="body" cellpadding="4" border="2">
    <colgroup>
        <col width="18%"><col width="18%"><col width="18%"><col width="46%">
    </colgroup>
    
    <thead>
        <tr valign="top">
            <th bgcolor="#B2B2B2">Input</th>
            <th bgcolor="#B2B2B2">Valid Settings</th>
            <th bgcolor="#B2B2B2">Default</th>
            <th bgcolor="#B2B2B2">Description</th>
        </tr>
    </thead>
    
    <tbody>

        <tr valign="top">
            <td bgcolor="#F2F2F2"><p><code>'CartInterp'</code></p></td>
            <td bgcolor="#F2F2F2"><p><code>'linear'</code><br><code>'nearest'</code></p></td>
            <td bgcolor="#F2F2F2"><p><code>'linear'</code></p></td>            
            <td bgcolor="#F2F2F2"><p>Interpolation mode used to extract the pressure when a Cartesian sensor mask is given. If set to <code>'nearest'</code> and more than one Cartesian point maps to the same grid point, duplicated data points are discarded and <code>sensor_data</code> will be returned with less points than that specified by <code>sensor.mask</code>.</p></td>
        </tr>
    
        <tr valign="top">
            <td bgcolor="#F2F2F2"><p><code>'CreateLog'</code></p></td>
            <td bgcolor="#F2F2F2"><p><em>(Boolean scalar)</em></p></td>
            <td bgcolor="#F2F2F2"><p><code>false</code></p></td>            
            <td bgcolor="#F2F2F2"><p>Boolean controlling whether the command line output is saved using the diary function with a date and time stamped filename.</p></td>
        </tr>        
        
        <tr valign="top">
            <td bgcolor="#F2F2F2"><p><code>'DataCast'</code></p></td>
            <td bgcolor="#F2F2F2"><p><em>(string of data type)</em></p></td>
            <td bgcolor="#F2F2F2"><p><code>'off'</code></p></td>            
            <td bgcolor="#F2F2F2"><p>String input of the data type that variables are cast to before computation. For example, setting to <code>'single'</code> will speed up the computation time (due to the improved efficiency of <code><a href="matlab: doc fftn">fftn</a></code> and <code><a href="matlab: doc ifftn">ifftn</a></code> for this data type) at the expense of a loss in precision. This variable is also useful for utilising GPU parallelisation through libraries such as the Parallel Computing Toolbox by setting <code>'DataCast'</code> to <code>'gpuArray-single'</code>.</p></td>
        </tr>    
        
		<tr valign="top">
            <td bgcolor="#F2F2F2"><p><code>'DataRecast'</code></p></td>
            <td bgcolor="#F2F2F2"><p><em>(Boolean scalar)</em></p></td>
            <td bgcolor="#F2F2F2"><p><code>false</code></p></td>            
            <td bgcolor="#F2F2F2"><p>Boolean controlling whether the output data is cast back to double precision. If set to false, <code>sensor_data</code> will be returned in the data format set using the <code>'DataCast'</code> option.</p></td>
        </tr>         
        
        <tr valign="top">
            <td bgcolor="#F2F2F2"><p><code>'DisplayMask'</code></p></td>
            <td bgcolor="#F2F2F2"><p><em>(binary matrix)</em> or<br/><code>'off'</code></p></td>
            <td bgcolor="#F2F2F2"><p><code>sensor.mask</code></p></td>            
            <td bgcolor="#F2F2F2"><p>Binary matrix overlayed onto the animated simulation display. Elements set to 1 within the display mask are set to black within the display.</p></td>
        </tr>            

        <tr valign="top">
            <td bgcolor="#F2F2F2"><p><code>'LogScale'</code></p></td>
            <td bgcolor="#F2F2F2"><p><em>(Boolean scalar)</em> or<br/><em>(numeric scalar)</em></p></td>
            <td bgcolor="#F2F2F2"><p><code>false</code></p></td>            
            <td bgcolor="#F2F2F2"><p>Boolean controlling whether the pressure field is log compressed before display. The data is compressed by scaling both the positive and negative values between 0 and 1 (truncating the data to the given plot scale), adding a scalar value (compression factor) and then using the corresponding portion of a log10 plot for the compression (the negative parts are remapped to be negative thus the default color scale will appear unchanged). The amount of compression can be controlled by adjusting the compression factor which can be given in place of the Boolean input. The closer the compression factor is to zero, the steeper the corresponding part of the log10 plot used, and the greater the compression (the default compression factor is 0.02).<p></td>
        </tr>

        <tr valign="top">
            <td bgcolor="#F2F2F2"><p><code>'MovieArgs'</code></p></td>
            <td bgcolor="#F2F2F2"><p><em>(string cell array)</em></p></td>
            <td bgcolor="#F2F2F2"><p><code>{}</code></p></td>            
            <td bgcolor="#F2F2F2"><p>Settings for <code><a href="matlab: doc movie2avi">movie2avi</a></code>. Parameters must be given as {param, value, ...} pairs within a cell array.</p></td>
        </tr> 

        <tr valign="top">
            <td bgcolor="#F2F2F2"><p><code>'MovieName'</code></p></td>
            <td bgcolor="#F2F2F2"><p><em>(string)</em></p></td>
            <td bgcolor="#F2F2F2"><p><code>'date-time-kspaceFirstOrder3D'</code></p></td>            
            <td bgcolor="#F2F2F2"><p>Name of the movie produced when <code>'RecordMovie'</code> is set to <code>true</code>.</p></td>
        </tr>            
        
        <tr valign="top">
            <td bgcolor="#F2F2F2"><p><code>'PlotFreq'</code></p></td>
            <td bgcolor="#F2F2F2"><p><em>(integer numeric scalar)</em></p></td>
            <td bgcolor="#F2F2F2"><p><code>10</code></p></td>            
            <td bgcolor="#F2F2F2"><p>The number of iterations which must pass before the simulation plot is updated.</p></td>
        </tr>        
        
        <tr valign="top">
            <td bgcolor="#F2F2F2"><p><code>'PlotLayout'</code></p></td>
            <td bgcolor="#F2F2F2"><p><em>(Boolean scalar)</em></p></td>
            <td bgcolor="#F2F2F2"><p><code>false</code></p></td>            
            <td bgcolor="#F2F2F2"><p>Boolean controlling whether three plots are produced of the initial simulation layout (initial pressure, sound speed, density).</p></td>
        </tr>        
        
        <tr valign="top">
            <td bgcolor="#F2F2F2"><p><code>'PlotPML'</code></p></td>
            <td bgcolor="#F2F2F2"><p><em>(Boolean scalar)</em></p></td>
            <td bgcolor="#F2F2F2"><p><code>true</code></p></td>            
            <td bgcolor="#F2F2F2"><p>Boolean controlling whether the perfectly matched layer is shown in the simulation plots. If set to <code>false</code>, the PML is not displayed.<p></td>
        </tr>

        <tr valign="top">
            <td bgcolor="#F2F2F2"><p><code>'PlotScale'</code></p></td>
            <td bgcolor="#F2F2F2"><p><em>(numeric two element vector)</em> or<br><code>'auto'</code></p></td>
            <td bgcolor="#F2F2F2"><p><code>[-1, 1]</code></p></td>            
            <td bgcolor="#F2F2F2"><p>[min, max] values used to control the scaling for <code><a href="matlab: doc imagesc">imagesc</a></code> (visualisation). If set to <code>'auto'</code>, a symmetric plot scale is chosen automatically for each plot frame.</p></td>
        </tr>            
        
        <tr valign="top">
            <td bgcolor="#F2F2F2"><p><code>'PlotSim'</code></p></td>
            <td bgcolor="#F2F2F2"><p><em>(Boolean scalar)</em></p></td>
            <td bgcolor="#F2F2F2"><p><code>true</code></p></td>            
            <td bgcolor="#F2F2F2"><p>Boolean controlling whether the simulation iterations are progressively plotted.</p></td>
        </tr>            
        
        <tr valign="top">
            <td bgcolor="#F2F2F2"><p><code>'PMLAlpha'</code></p></td>
            <td bgcolor="#F2F2F2"><p><em>(numeric scalar or three element vector)</em></p></td>
            <td bgcolor="#F2F2F2"><p><code>2</code></p></td>            
            <td bgcolor="#F2F2F2"><p>Absorption within the perfectly matched layer in Nepers per grid point.</p></td>
        </tr>        
        
        <tr valign="top">
            <td bgcolor="#F2F2F2"><p><code>'PMLInside'</code></p></td>
            <td bgcolor="#F2F2F2"><p><em>(Boolean scalar)</em></p></td>
            <td bgcolor="#F2F2F2"><p><code>true</code></p></td>            
            <td bgcolor="#F2F2F2"><p>Boolean controlling whether the perfectly matched layer is inside or outside the grid. If set to <code>false</code>, the input grids are enlarged by <code>PMLSize</code> before running the simulation.</p></td>
        </tr>            
        
        <tr valign="top">
            <td bgcolor="#F2F2F2"><p><code>'PMLSize'</code></p></td>
            <td bgcolor="#F2F2F2"><p><em>(integer numeric scalar or three element vector)</em></p></td>
            <td bgcolor="#F2F2F2"><p><code>10</code></p></td>            
            <td bgcolor="#F2F2F2"><p>Size of the perfectly matched layer in grid points. By default, the PML is added evenly to all sides of the grid, however, both <code>PMLSize</code> and <code>PMLAlpha</code> can be given as three element arrays to specify the x, y, and z properties, respectively. To remove the PML, set the appropriate <code>PMLAlpha</code> to zero rather than forcing the PML to be of zero size.</p></td>
        </tr>                  
        
        <tr valign="top">
            <td bgcolor="#F2F2F2"><p><code>'RecordMovie'</code></p></td>
            <td bgcolor="#F2F2F2"><p><em>(Boolean scalar)</em></p></td>
            <td bgcolor="#F2F2F2"><p><code>false</code></p></td>            
            <td bgcolor="#F2F2F2"><p>Boolean controlling whether the displayed image frames are captured and stored as a movie using <code><a href="matlab: doc movie2avi">movie2avi</a></code>.</p></td>
        </tr>          
        
        <tr valign="top">
            <td bgcolor="#F2F2F2"><p><code>'Smooth'</code></p></td>
            <td bgcolor="#F2F2F2"><p><em>(Boolean scalar or three element vector)</em></p></td>
            <td bgcolor="#F2F2F2"><p><code>[true, false, false]</code></p></td>            
            <td bgcolor="#F2F2F2"><p>Boolean controlling whether <code>source.p0</code>, <code>medium.sound_speed</code>, and <code>medium.density</code> are smoothed using <code><a href="smooth.html">smooth</a></code> before computation. <code>'Smooth'</code> can either be given as a single Boolean value or as a 3 element array to control the smoothing of <code>source.p0</code>, <code>medium.sound_speed</code>, and <code>medium.density</code>, independently.</p></td>
        </tr>      
        
        <tr valign="top">
            <td bgcolor="#F2F2F2"><p><code>'SaveToDisk'</code></p></td>
            <td bgcolor="#F2F2F2"><p><em>(string)</em></p></td>
            <td bgcolor="#F2F2F2"><p><code>''</code></p></td>            
            <td bgcolor="#F2F2F2"><p>String containing a filename (including pathname if required). If set, after the precomputation phase, the input variables used in the time loop are saved the specified location in HDF5 format. The simulation then exits. The saved variables can be used to run simulations using the C++ code.</p></td>
        </tr>
        
        <tr valign="top">
            <td bgcolor="#F2F2F2"><p><code>'StreamToDisk'</code></p></td>
            <td bgcolor="#F2F2F2"><p><em>(Boolean scalar or integer numeric scalar)</em></p></td>
            <td bgcolor="#F2F2F2"><p><code>false</code></p></td>            
            <td bgcolor="#F2F2F2"><p>Boolean controlling whether <code>sensor_data</code> is periodically saved to disk to avoid storing the complete matrix in memory. <code>StreamToDisk</code> may also be given as an integer which specifies the number of times steps that are taken before the data is saved to disk (default = 200).</p></td>
        </tr>
                
    </tbody>
</table>

<h2>Outputs</h2>

<p>If <code>sensor.record</code> is not defined by the user:</p>

<table cellspacing="0" class="body" cellpadding="4" border="0">
    <tr valign="top">
        <td width = "150"><p><code>sensor_data</code></p></td>
        <td><p>time varying pressure recorded at the sensor positions given by <code>sensor.mask</code></p></td>
    </tr>  
</table>

<p>If <code>sensor.record</code> is defined by the user:</p>

<table cellspacing="0" class="body" cellpadding="4" border="0">
    <tr valign="top">
        <td width = "150"><p><code>sensor_data.p</code></p></td>
        <td><p>time varying pressure recorded at the sensor positions given by <code>sensor.mask</code> (returned if <code>'p'</code> is set)</p></td>
    </tr>
	<tr valign="top">
        <td width = "150"><p><code>sensor_data.p_max</code></p></td>
        <td><p>maximum pressure recorded at the sensor positions given by <code>sensor.mask</code> (returned if <code>'p_max'</code> is set)</p></td>
    </tr>
	<tr valign="top">
        <td width = "150"><p><code>sensor_data.p_min</code></p></td>
        <td><p>minimum pressure recorded at the sensor positions given by <code>sensor.mask</code> (returned if <code>'p_min'</code> is set)</p></td>
    </tr>      
	<tr valign="top">
        <td width = "150"><p><code>sensor_data.p_rms</code></p></td>
        <td><p>rms of the time varying pressure recorded at the sensor positions given by <code>sensor.mask</code> (returned if <code>'p_rms'</code> is set)</p></td>
    </tr>
    <tr valign="top">
        <td width = "150"><p><code>sensor_data.p_final</code></p></td>
        <td><p>final pressure field at all grid points within the domain (returned if <code>'p_final'</code> is set)</p></td>
    </tr>
	<tr valign="top">
        <td width = "150"><p><code>sensor_data.p_max_all</code></p></td>
        <td><p>maximum pressure recorded at all grid points within the domain (returned if <code>'p_max_all'</code> is set)</p></td>
    </tr>
	<tr valign="top">
        <td width = "150"><p><code>sensor_data.p_min_all</code></p></td>
        <td><p>minimum pressure recorded at all grid points within the domain (returned if <code>'p_min_all'</code> is set)</p></td>
    </tr>      
    <tr valign="top">
        <td width = "150"><p><code>sensor_data.ux</code></p></td>
        <td><p>time varying particle velocity in the x-direction recorded at the sensor positions given by <code>sensor.mask</code> (returned if <code>'u'</code> is set)</p></td>
    </tr>
    <tr valign="top">
        <td width = "150"><p><code>sensor_data.uy</code></p></td>
        <td><p>time varying particle velocity in the y-direction recorded at the sensor positions given by <code>sensor.mask</code> (returned if <code>'u'</code> is set)</p></td>
    </tr>
    <tr valign="top">
        <td width = "150"><p><code>sensor_data.uz</code></p></td>
        <td><p>time varying particle velocity in the z-direction recorded at the sensor positions given by <code>sensor.mask</code> (returned if <code>'u'</code> is set)</p></td>
    </tr> 
    <tr valign="top">
        <td width = "150"><p><code>sensor_data.ux_max</code></p></td>
        <td><p>maximum particle velocity in the x-direction recorded at the sensor positions given by <code>sensor.mask</code> (returned if <code>'u_max'</code> is set)</p></td>
    </tr>
	<tr valign="top">
        <td width = "150"><p><code>sensor_data.uy_max</code></p></td>
        <td><p>maximum particle velocity in the y-direction recorded at the sensor positions given by <code>sensor.mask</code> (returned if <code>'u_max'</code> is set)</p></td>
    </tr>
	<tr valign="top">
        <td width = "150"><p><code>sensor_data.uz_max</code></p></td>
        <td><p>maximum particle velocity in the z-direction recorded at the sensor positions given by <code>sensor.mask</code> (returned if <code>'u_max'</code> is set)</p></td>
    </tr>   
    <tr valign="top">
        <td width = "150"><p><code>sensor_data.ux_min</code></p></td>
        <td><p>minimum particle velocity in the x-direction recorded at the sensor positions given by <code>sensor.mask</code> (returned if <code>'u_min'</code> is set)</p></td>
    </tr>
	<tr valign="top">
        <td width = "150"><p><code>sensor_data.uy_min</code></p></td>
        <td><p>minimum particle velocity in the y-direction recorded at the sensor positions given by <code>sensor.mask</code> (returned if <code>'u_min'</code> is set)</p></td>
    </tr>
	<tr valign="top">
        <td width = "150"><p><code>sensor_data.uz_min</code></p></td>
        <td><p>minimum particle velocity in the z-direction recorded at the sensor positions given by <code>sensor.mask</code> (returned if <code>'u_min'</code> is set)</p></td>
    </tr>     
    <tr valign="top">
        <td width = "150"><p><code>sensor_data.ux_rms</code></p></td>
        <td><p>rms of the time varying particle velocity in the x-direction recorded at the sensor positions given by <code>sensor.mask</code> (returned if <code>'u_rms'</code> is set)</p></td>
    </tr>
    <tr valign="top">
        <td width = "150"><p><code>sensor_data.uy_rms</code></p></td>
        <td><p>rms of the time varying particle velocity in the y-direction recorded at the sensor positions given by <code>sensor.mask</code> (returned if <code>'u_rms'</code> is set)</p></td>
    </tr>
    <tr valign="top">
        <td width = "150"><p><code>sensor_data.uz_rms</code></p></td>
        <td><p>rms of the time varying particle velocity in the z-direction recorded at the sensor positions given by <code>sensor.mask</code> (returned if <code>'u_rms'</code> is set)</p></td>
    </tr>
    <tr valign="top">
        <td width = "150"><p><code>sensor_data.ux_final</code></p></td>
        <td><p>final particle velocity field in the x-direction at all grid points within the domain (returned if <code>'u_final'</code> is set)</p></td>
    </tr>
    <tr valign="top">
        <td width = "150"><p><code>sensor_data.uy_final</code></p></td>
        <td><p>final particle velocity field in the y-direction at all grid points within the domain (returned if <code>'u_final'</code> is set)</p></td>
    </tr>
    <tr valign="top">
        <td width = "150"><p><code>sensor_data.uz_final</code></p></td>
        <td><p>final particle velocity field in the z-direction at all grid points within the domain (returned if <code>'u_final'</code> is set)</p></td>
    </tr>
    <tr valign="top">
        <td width = "150"><p><code>sensor_data.ux_max_all</code></p></td>
        <td><p>maximum particle velocity in the x-direction recorded at all grid points within the domain (returned if <code>'u_max_all'</code> is set)</p></td>
    </tr>
	<tr valign="top">
        <td width = "150"><p><code>sensor_data.uy_max_all</code></p></td>
        <td><p>maximum particle velocity in the y-direction recorded at all grid points within the domain (returned if <code>'u_max_all'</code> is set)</p></td>
    </tr>
	<tr valign="top">
        <td width = "150"><p><code>sensor_data.uz_max_all</code></p></td>
        <td><p>maximum particle velocity in the z-direction recorded at all grid points within the domain (returned if <code>'u_max_all'</code> is set)</p></td>
    </tr>   
    <tr valign="top">
        <td width = "150"><p><code>sensor_data.ux_min_all</code></p></td>
        <td><p>minimum particle velocity in the x-direction recorded at all grid points within the domain (returned if <code>'u_min_all'</code> is set)</p></td>
    </tr>
	<tr valign="top">
        <td width = "150"><p><code>sensor_data.uy_min_all</code></p></td>
        <td><p>minimum particle velocity in the y-direction recorded at all grid points within the domain (returned if <code>'u_min_all'</code> is set)</p></td>
    </tr>
	<tr valign="top">
        <td width = "150"><p><code>sensor_data.uz_min_all</code></p></td>
        <td><p>minimum particle velocity in the z-direction recorded at all grid points within the domain (returned if <code>'u_min_all'</code> is set)</p></td>
    </tr>       
    <tr valign="top">
        <td width = "150"><p><code>sensor_data.ux_non_staggered</code></p></td>
        <td><p>time varying particle velocity in the x-direction recorded at the sensor positions given by <code>sensor.mask</code> after shifting to the non-staggered grid (returned if <code>'u_non_staggered'</code> is set)</p></td>
    </tr>
    <tr valign="top">
        <td width = "150"><p><code>sensor_data.uy_non_staggered</code></p></td>
        <td><p>time varying particle velocity in the y-direction recorded at the sensor positions given by <code>sensor.mask</code> after shifting to the non-staggered grid (returned if <code>'u_non_staggered'</code> is set)</p></td>
    </tr>
    <tr valign="top">
        <td width = "150"><p><code>sensor_data.uz_non_staggered</code></p></td>
        <td><p>time varying particle velocity in the z-direction recorded at the sensor positions given by <code>sensor.mask</code> after shifting to the non-staggered grid (returned if <code>'u_non_staggered'</code> is set)</p></td>
    </tr>     
    <tr valign="top">
        <td width = "150"><p><code>sensor_data.Ix</code></p></td>
        <td><p>time varying acoustic intensity in the x-direction recorded at the sensor positions given by <code>sensor.mask</code> (returned if <code>'I'</code> is set)</p></td>
    </tr>
    <tr valign="top">
        <td width = "150"><p><code>sensor_data.Iy</code></p></td>
        <td><p>time varying acoustic intensity in the y-direction recorded at the sensor positions given by <code>sensor.mask</code> (returned if <code>'I'</code> is set)</p></td>
    </tr>
    <tr valign="top">
        <td width = "150"><p><code>sensor_data.Iz</code></p></td>
        <td><p>time varying acoustic intensity in the z-direction recorded at the sensor positions given by <code>sensor.mask</code> (returned if <code>'I'</code> is set)</p></td>
    </tr>	
    <tr valign="top">
        <td width = "150"><p><code>sensor_data.Ix_avg</code></p></td>
        <td><p>average acoustic intensity in the x-direction recorded at the sensor positions given by <code>sensor.mask</code> (returned if <code>'I_avg'</code> is set)</p></td>
    </tr>
    <tr valign="top">
        <td width = "150"><p><code>sensor_data.Iy_avg</code></p></td>
        <td><p>average acoustic intensity in the z-direction recorded at the sensor positions given by <code>sensor.mask</code> (returned if <code>'I_avg'</code> is set)</p></td>
    </tr>
    <tr valign="top">
        <td width = "150"><p><code>sensor_data.Iz_avg</code></p></td>
        <td><p>average acoustic intensity in the z-direction recorded at the sensor positions given by <code>sensor.mask</code> (returned if <code>'I_avg'</code> is set)</p></td>
    </tr>	
</table>

<h2>Examples</h2>
<ul>
<li><a href="example_ivp_3D_simulation.html">Simulations In Three Dimensions</a></li> 
<li><a href="example_ivp_photoacoustic_waveforms.html">Photoacoustic Waveforms in 1D, 2D and 3D</a></li> 
<li><a href="example_tvsp_3D_simulation.html">Simulations In Three-Dimensions</a></li>
<li><a href="example_sd_focussed_detector_3D.html">Focussed Detector in 3D</a></li>
<li><a href="example_sd_directivity_modelling_3D.html">Modelling Sensor Directivity in 3D</a></li>           
<li><a href="example_pr_3D_fft_planar_sensor.html">3D FFT Reconstruction For A Planar Sensor</a></li>
<li><a href="example_pr_3D_tr_planar_sensor.html">3D Time Reversal For A Planar Sensor</a></li> 
<li><a href="example_pr_3D_tr_spherical_sensor.html">3D Time Reversal For A Spherical Sensor</a></li>                      		
<li><a href="example_us_defining_transducer.html">Defining An Ultrasound Transducer</a></li> 
<li><a href="example_us_beam_patterns.html">Simulating Ultrasound Beam Patterns</a></li> 
<li><a href="example_us_transducer_as_sensor.html">Using An Ultrasound Transducer As A Sensor</a></li> 
<li><a href="example_us_bmode_linear_transducer.html">Simulating B-mode Ultrasound Images</a></li> 
<li><a href="example_us_bmode_phased_array.html">Simulating B-mode Images Using A Phased Array</a></li>
<li><a href="example_cpp_running_simulations.html">Running C++ Simulations</a></li>
</ul>

<h2>See Also</h2>

<code><a href="benchmark.html">benchmark</a></code>, <code><a href="matlab: doc fftn">fftn</a></code>, <code><a href="matlab: doc ifftn">ifftn</a></code>, <code><a href="matlab: doc imagesc">imagesc</a></code>, <code><a href="kspaceFirstOrder1D.html">kspaceFirstOrder1D</a></code>, <code><a href="kspaceFirstOrder2D.html">kspaceFirstOrder2D</a></code>, <code><a href="makeGrid.html">makeGrid</a></code>, <code><a href="makeTime.html">makeTime</a></code>, <code><a href="makeTransducer.html">makeTransducer</a></code>, <code><a href="smooth.html">smooth</a></code>, <code><a href="unmaskSensorData.html">unmaskSensorData</a></code>

<p></p>
<table class="nav" summary="Navigation aid" border="0" width="100%" cellpadding="0" cellspacing="0" bgcolor="#e7ebf7">
    <tr valign="top">
        <td align="left" width="20"><a href="kspaceFirstOrder2D.html"><img src="images/b_prev.gif" border="0" align="bottom" alt="Previous"></a>&nbsp;</td>
        <td align="left">kspaceFirstOrder2D</td>
        <td>&nbsp;</td>
        <td align="right">kspaceFirstOrder3DC</td>
        <td align="right" width="20"><a href="kspaceFirstOrder3DC.html"><img src="images/b_next.gif" border="0" align="bottom" alt="Next"></a></td>
    </tr>
</table>

<br>
<p class="copy">&copy; 2009-2014 Bradley Treeby and Ben Cox.</p>
</body></html>